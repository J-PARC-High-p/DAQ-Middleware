#include <iostream>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <string>
#include <arpa/inet.h>
#include "string.h"
#include <errno.h>
#include <fcntl.h>
#include <netinet/tcp.h>

using namespace std;

const int MAXHOSTNAME = 200;
const int MAXCONNECTIONS = 5;
const int MAXRECV = 500;

class Socket
{
 public:
  Socket() :
    m_sock ( -1 )
    {
      memset ( &m_addr, 0, sizeof ( m_addr ) );
    }

  ~Socket()
    {
      if ( is_valid() )
	::close ( m_sock );
    }

  // Server initialization
  bool create()
    {
      m_sock = socket ( AF_INET, SOCK_STREAM, 0 );
      if ( ! is_valid() )
	return false;
      // TIME_WAIT - argh
      int on = 1;
      if ( setsockopt ( m_sock, SOL_SOCKET, SO_REUSEADDR, ( const char* ) &on, sizeof ( on ) ) == -1 )
	return false;
      
      if( setsockopt ( m_sock, IPPROTO_TCP, TCP_NODELAY, ( const char* ) &on, sizeof (on) ) == -1)
	return false;
      
      return true;
    }

  bool bind ( const int port )
    {
      if ( ! is_valid() )
	{
	  return false;
	}
      m_addr.sin_family = AF_INET;
      m_addr.sin_addr.s_addr = INADDR_ANY;
      m_addr.sin_port = htons ( port );
      int bind_return = ::bind ( m_sock,
				 ( struct sockaddr * ) &m_addr,
				 sizeof ( m_addr ) );
      if ( bind_return == -1 )
	{
	  return false;
	}
      return true;
    }

  // Data Transimission
  bool listen() const
    {
      if ( ! is_valid() )
	{
	  return false;
	}
      int listen_return = ::listen ( m_sock, MAXCONNECTIONS );
      if ( listen_return == -1 )
	{
	  return false;
	}
      return true;
    }

  bool accept ( Socket& new_socket ) const
    {
      int addr_length = sizeof ( m_addr );
      new_socket.m_sock = ::accept ( m_sock, ( sockaddr * ) &m_addr, ( socklen_t * ) &addr_length );
      
      if ( new_socket.m_sock <= 0 )
	return false;
      else
	return true;
    }

  bool send ( const std::string s ) const
    {
      int status = ::send ( m_sock, s.c_str(), s.size(), MSG_NOSIGNAL );
      if ( status == -1 )
	{
	  return false;
	}
      else
	{
	  return true;
	}
    }

  int recv ( std::string& s ) const
    {
      char buf [ MAXRECV + 1 ];
      
      s = "";
      
      memset ( buf, 0, MAXRECV + 1 );
      int status = ::recv ( m_sock, buf, MAXRECV, 0 );
      if ( status == -1 )
	{
	  std::cout << "status == -1   errno == " << errno << "  in Socket::recv\n";
	  return 0;
	}
      else if ( status == 0 )
	{
	  return 0;
	}
      else
	{
	  s = buf;
	  return status;
	}
    }

  bool send ( const int* s, int size ) const
    {
      int status = ::send ( m_sock, s, size, MSG_NOSIGNAL );
      if ( status == -1 )
	{
	  return false;
	}
      else
	{
	  return true;
	}
    }

  int recv ( int* s , int size) const {
    char buf [ MAXRECV + 1 ];
    char* p = (char*)s;
    int lenRecv = 0;
    while ( lenRecv < size ) {
      int len = ::recv(m_sock, buf, (size - lenRecv) > MAXRECV ? MAXRECV :(size - lenRecv), 0);
      if (len < 0) {
        std::cout << "status == -1   errno == " << errno << "  in Socket::recv\n";
        return 0;
      } else if (len == 0) {
        break;
      } else {
        memcpy(p, buf, len);
        p += len;
        lenRecv += len;
      }
    }
    return lenRecv;
  }

  bool connect ( const std::string host, const int port )
    {
      if ( ! is_valid() ) return false;
      m_addr.sin_family = AF_INET;
      m_addr.sin_port = htons ( port );
      int status = inet_pton ( AF_INET, host.c_str(), &m_addr.sin_addr );
      if ( errno == EAFNOSUPPORT ) return false;
      status = ::connect ( m_sock, ( sockaddr * ) &m_addr, sizeof ( m_addr ) );
      if ( status == 0 )
	return true;
      else
	return false;
    }

  void set_non_blocking ( const bool b )
    {
      int opts;
      opts = fcntl ( m_sock, F_GETFL );
      if ( opts < 0 )
	{
	  return;
	}
      if ( b )
	opts = ( opts | O_NONBLOCK );
      else
	opts = ( opts & ~O_NONBLOCK );
      
      fcntl ( m_sock, F_SETFL,opts );
    }

  bool is_valid() const { return m_sock != -1; }

 private:
  int m_sock;
  sockaddr_in m_addr;
};

class SocketException
{
 public:
  SocketException ( std::string s ) : m_s ( s ) {};
  ~SocketException (){};
  std::string description() { return m_s; }

 private:
  std::string m_s;
};

class ClientSocket : private Socket
{
 public:
  ClientSocket() {};
  ClientSocket ( std::string host, int port )
    {
      cout << "ClientSocket ( std::string host, int port ) is called" << endl;
      cout << "host = " << host << "  port = " << port << endl;
      if ( ! Socket::create() )
	{
	  throw SocketException ( "Could not create client socket." );
	}
      cout << "ClientSocket::create: done" << endl;
      if ( ! Socket::connect ( host, port ) )
	{
	  throw SocketException ( "Could not bind to port." );
	}
      cout << "ClientSocket::connect: done" << endl;
    }

  const ClientSocket& operator << ( const std::string& s ) const
    {
      if ( ! Socket::send ( s ) )
	{
	  throw SocketException ( "Could not write to socket." );
	}
      return *this;
    }

  const ClientSocket& operator >> ( std::string& s ) const
    {
/*
      if ( ! Socket::recv ( s ) )
	{
	  throw SocketException ( "Could not read from socket." );
	}
    
*/

  int buf[2];
  if ( ! Socket::recv((int*)buf, sizeof(int)) )
    {
      throw SocketException ( "Could not read from socket." );
    }
//  std::cout << "buf1=" << buf[0] << std::endl;
  int size = buf[0];
  
  char *buf2 = ((char *)calloc(size+1, sizeof(char)));
  if ( ! Socket::recv(( int*)buf2, size) )
    {
      throw SocketException ( "Could not read from socket." );
    }
//  std::cout << "buf2=" << buf2 << std::endl;
  buf2[size] = '\0';
  
  s = buf2;
  delete(buf2);

      return *this;
    }

  void write( const int* s, int size )
    {
      if ( ! Socket::send ( s, size ) )
	{
	  throw SocketException ( "Could not write to socket." );
	}
    }

  int read( int* s, int size )
    {
      int status;
      status =  Socket::recv ( s, size );
      if ( !status )
	{
	  throw SocketException ( "Could not read from socket." );
	}
      return status;
    }
};

class ParameterClient {
 public:
  ParameterClient(std::string host, int port, string delimitor)
    : m_host(host), m_port(port), m_delimitor(delimitor),
    m_clientSock( m_host, m_port ) {
      cout << "host = " << m_host <<  "   port = " << m_port << "   delimitor = " << m_delimitor << endl;
    };
  ParameterClient(std::string host, int port)
    : m_host(host), m_port(port),
    m_clientSock( m_host, m_port ) {
      m_delimitor = ":";
      cout << "host = " << m_host <<  "   port = " << m_port << "   delimitor = " << m_delimitor << endl;
    };
  ParameterClient() {
    cout << "no parameter" << endl;
  }
  ~ParameterClient() {}
  int put(std::string id, std::string value, std::string& result);
  int put2(std::string id, std::string value, std::string& result);
  int get(std::string id, std::string& value);
  string* new_strp();
  string strp_value(string *self);

 private:
  std::string m_host;
  int m_port;
  string m_delimitor;
  ClientSocket m_clientSock;
  
};

string* ParameterClient::new_strp() {
  return (new string);
}

string ParameterClient::strp_value(string *self) {
  return *self;
}

int ParameterClient::put(std::string id, std::string value, std::string& result) {
  std::string status;

  std::string msg = "put"+ m_delimitor + id + m_delimitor + value;
  
  int buf[2];
  buf[0] = msg.length();
  m_clientSock.write((int*)buf, sizeof(int));
  
  m_clientSock << msg;
  m_clientSock >> status; 
  cout << "status = " << status << endl;
  
  if(status.length() > 0) {
    result = status;
    return 1;
  }
  return 0;
}

int ParameterClient::put2(std::string id, std::string value, std::string& result) {
  return put(id, value, result);
}

int ParameterClient::get(std::string id, std::string& value) {
  std::string status, valuetmp;

  std::string msg = "get" + m_delimitor + id;
  
  int buf[2];
  buf[0] = msg.length();
  m_clientSock.write((int*)buf, sizeof(int));
  
  m_clientSock << msg;
  m_clientSock >> status;
  cout << "status = " << status << endl;
  
  if(status.length() > 0) {
    value = status;
    return 1;
  }
  return 0;
}

